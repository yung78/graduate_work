# Описание backend:

- [Общая информация](#общая-информация)  

- [Развертывание сервера](#развёртывание-сервера-на-платформе-regru)


 ## Общая информация

При разработке серверной части приложения принял решениене не переиспользовать готовые решения Django, а составить схему БД, проверку аутентификации и авторизации самостоятельно.

Схема хранения информации в базе данных проекта:  
![бд](./readme_res/схема-бд.png)  


Хранение файлов и аватаров организовано в соответствующих директориях с распределением по папкам с id пользователя.
Удаление файлов с физического диска производит библиотека django-cleanup.

При прохождении аутентификации(при входе) генерируется токен сессии который сохраняется в бд и передается в теле ответа клиенту. На клиенте браузер получив токен, сохраняет его в localForage, после чего токен передается в заголовках каждого  запроса. Получив запрос сервер перед каждым действием проверяет существование данного токена в БД, чтобы убедиться в прохождении аутентификации клиентом.  
Дополнительно периодически производится проверка аккаунта на "флаг" наличия прав администратора.

При обратной аутентификации(при выходе) токен удаляется из БД и из браузера на клиенте.  

При необходимости можно реализовать функцию проверки даты/времени создания токена и удалять его из бд после прохождения какого-то срока.

 ## Развёртывание сервера на платформе reg.ru

Для доступа к управлению сервером генерируем SSH в своей системе:  
```bash
ssh-keygen
```  

Переходим на сайт [reg.ru](https://www.reg.ru), проходим аутентификацию/регистрацию. Заходим в облачные сервисы и приступаем к созданию нового сервера:  
![reg.ru](./readme_res/create_server.png)  

Копируем сгенерированный ssh:  
```bash
cat ~/.ssh/id_rsa.pub
```
![ssh_copy](./readme_res/ssh_copy.png)  

вставляем ssh в соответствующее поле при создании сервера:  
![ssh_paste](./readme_res/ssh_paste.png)  

Через несколько минут после отправки запроса на создание сервера, индикация статуса подвердждает создание и работу сервера:  
![created](./readme_res/server_created.png)  
а на на почту, к которой привязан аккаунт reg.ru, приходят ip и пароль для управления сервером.  
Заходим через консоль на сервер :
``` bash
ssh root@0.0.0.0
```
где вместо 0.0.0.0 вводим ip созданного сервера.  
Далее по запросу вводим пароль и получаем root доступ к системе сервера:  
![root](./readme_res/root.png)  

Создаем нового пользователя, чтоб с root правами ничего не "сломать":
```bash
adduser user
```
где вместо user вводим имя нового пользователя. Задаем пароль, задаем данные о пользователе(можно оставить пустыми), подтверждаем правильность введенных данных - пользователь создан. 

Наделяем вновь созданного пользователя правами superuser(su):
```bash
usermod user -aG sudo
```
где вместо user вводим имя нового пользователя.  

Переподключаемся на вновь созданного пользователя:
```bash
logout
ssh user@0.0.0.0
```
где вместо user вводим имя нового пользователя, вместо 0.0.0.0 вводим ip созданного сервера.  

Приступаем к установке необходимых пакетов.  
Перед установкой обновляем список репозиториев:
```bash
sudo apt update
```
Рекомендуется так же установить последние стабильные версии установленных пакетов:
```bash
sudo apt upgrade
```
Пакеты с обновлениями системы облака(Configuring openssh-server, Configuration file), на которые приходили отдельные подтверждения, не обновлял(keep stable version). 

Устанавливаем необходимые пакеты:
```bash
sudo apt-get install python3 python3-venv python3-pip postgresql nginx
```
Проверить установленный пает можно командой:
```bash
packadge_name --version 
```
где вместо packadge_name вводим имя пакета. Например проверяем установку python:
```bash
python3 --version 
```
активацию postgres:
```bash
sudo systemctl status postgresql
```

По примеру видеолекции "Практика с сервером" для удобства создаем пользователя в psql имя которого соответствует имени пользователя в системе:
```bash
sudo su postgres
psql
CREATE USER user WITH SUPERUSER;
ALTER USER user WITH PASSWORD '...';
CREATE DATABASE user;
```
где вместо user вводим имя пользователя, вместо ... - пароль.  
**Имя пользователя и название системной БД должны совпадать!**  

Выходим из psql и подключаемся обратно через пользователя user и создаем базу данных для проекта:
```bash
\q
exit
psql
CREATE DATABASE name;
\q
```
где вместо name вводим имя БД проекта.

В домашней директории пользователя клонируем репозиторий нашего проекта и опускаемся по папкам проекта до директории с файлом manage.py, затем устанавливаем и активируем виртуальное окружение:
```bash
python3 -m venv .venv
source .venv/bin/activate
```
Далее устанавливаем все пакеты из requirements.txt и проверяем их установку:
```bash
pip install -r requirements.txt
pip freeze
```
Создаем файл .env и прописываем переменные окружения.  Пример:
![env](./readme_res/env.png)  

Проверяем корректное использование переменного окружения в настройках и сами настройки проекта в файле settings.py.  
Запускаем миграции и загружаем данные из заранее подготовленного файла loaddata.json:
```bash
python manage.py migrate
python manage.py loaddata loaddata.json
```
Если миграции не прошли - перепроверяем настройки!  

Далее настраиваем gunicorn в соответствии с примером из записи вебинара:  
```bash
sudo nano /etc/systemd/system/gunicorn.service
```
Настройки на данном проекте:  
![gunicorn](./readme_res/gunicorn.png)  

Проверка правильности настроек:  
```bash
sudo systemctl start gunicorn
sudo systemctl enable gunicorn
sudo systemctl status gunicorn
```
Если все настройки прописаны верно - после ввода последней команды мы увидим, что gunicorn активен:  
![active](./readme_res/gunicorn_active.png)  

Если сборка frontend-а не была произведена: на локалньном ресурсе производим сборку, удаляем папку build из .gitignore, коммитим и сохраняем/отправляем изменения на удаленном репозиторий и подтягиваем изменения со сборкой на облачный сервер.  

Теперь перейдем к настройкам nginx.  
Создадим новый файл, можно без расширения, имя выбираем самостоятельно:
```bash
sudo nano /etc/nginx/sites-available/cloud
```
где следуя примеру из вебинара, почитав пару дней статьи и ответы на форумах, 100500 раз перефразируя вопрос в поисковике, и задав пару вопросов в учебном чате) прописываем настройки.   

Настройки на данном проекте:  
![gunicorn](./readme_res/nginx.png)  
где также задается путь к изображениям - 'location /media/'.

Cоздаем символическую ссылку на этот файл в другую директорию:
```bash
sudo ln -s /etc/nginx/sites-available/cloud /etc/nginx/sites-enabled
```

Настраиваем максимальнвй размер присылаемых файлов. Для этого заходим в основные настройки сервера:
```bash
sudo nano /etc/nginx/nginx.conf
```
и устанавливаем необходимый размер(в данном примере 5мб), добавив записи в http{}  
client_max_body_size 5M;  
client_body_buffer_size 5M;

Перезапускаем сервер nginx и проверяем статус:
```bash
sudo systemctl stop nginx
sudo systemctl start nginx
sudo systemctl status nginx
```
Для корректировки и отладки настроек используем логи nginx:
```bash
sudo nano /var/log/nginx/access.log
sudo nano /var/log/nginx/error.log
```

Если все сделали правильно - увидим статус 'active':
![nginx](./readme_res/nginx_active.png)  


Будьте внимательны с настройками. Периодически забывая поставить "**;**" в конце строки получал ошибку при запуске:  
![err](./readme_res/nginx_error.png) 

После всех, перечисленных выше, действий все должно заработать по ip адресу в адресной строке браузера:  
![работает](./readme_res/work.png) 

P.S.  
Не забывайте запускать gunicorn при запуске после остановки облачного сервера.  

## Итог
Не смог добиться отображения фавикона. Возможно, до проверки исправлю, но пока сдаю как есть.
